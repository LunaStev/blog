---
title: "미래에 없어질 프로그래밍 언어라는 말에 대하여"
date: "2025-12-27"
---

최근에 *미래에는 사라질 수도 있는 프로그래밍 언어*를 다룬 글을 하나 읽었다. 그 글은 Objective-C, COBOL, Delphi, Smalltalk, Haskell을 언급하며 이 언어들이 장기적으로는 도태될 가능성이 있다고 이야기했다. 하지만 그 목록을 처음 봤을 때부터 나는 이 주장에 쉽게 동의하기 어려웠다. 이유는 단순하다. 이 언어들 대부분은 이미 “유행”의 단계가 아니라, “기반”의 단계에 들어가 있기 때문이다.

프로그래밍 언어가 사라진다는 말은 생각보다 무거운 표현이다. 단순히 인기가 줄어들거나, 신규 프로젝트에서 선택되지 않는 것과는 전혀 다른 문제다. 언어가 정말로 사라지려면, 그 언어로 만들어진 수많은 시스템과 인프라, 그리고 그 위에서 돌아가는 현실 세계의 기능들까지 함께 사라져야 한다. 과연 그런 일이 실제로 가능한가를 생각해보면, 답은 쉽게 나오지 않는다.

---

## 내가 직접 겪은 Haskell, 그리고 언어 선택의 문제

이 다섯 개의 언어 중에서 내가 직접 사용해본 언어는 Haskell이다. Wave 개발 초창기, 파서와 컴파일러 구조를 잡기 위해 여러 언어로 프로토타입을 실험하던 시기가 있었는데, 그때 Haskell도 자연스럽게 선택지에 올라왔다. 컴파일러를 처음부터 끝까지 직접 설계해보려다 보니, 상태 변화가 적고 수학적으로 구조화된 언어가 훨씬 사고하기 편하다는 걸 체감하게 됐기 때문이다.

실제로 Haskell로 파서를 작성해보면, 문법 트리나 변환 과정이 코드에 거의 그대로 드러난다. 함수 하나하나가 명확한 변환을 표현하고, 부수 효과가 거의 없기 때문에 “이 코드가 무슨 일을 하는지”를 추론하기가 쉽다. 이런 특성 덕분에 언어 이론이나 컴파일러 연구 분야에서는 함수형 언어가 오랫동안 중요한 도구로 사용되어 왔다. 이건 취향의 문제가 아니라, 문제의 성격과 언어의 구조가 잘 맞기 때문이다.

하지만 프로토타입 단계를 넘어서, 실제로 하나의 언어를 끝까지 구현하고 유지해야 하는 상황이 되자 요구 조건이 달라졌다. 단순히 이론적으로 아름다운 코드가 아니라, 성능을 예측할 수 있어야 했고, 메모리와 실행 흐름을 명확하게 통제할 수 있어야 했다. 무엇보다도, 혼자 개발을 이어가면서도 장기적으로 확장 가능한 생태계가 필요했다.

그래서 최종적으로 선택한 언어가 Rust였다. 이 선택은 Haskell이 부족해서가 아니었다. 오히려 Haskell은 특정 영역에서는 너무 잘 맞는 언어였고, 그렇기 때문에 다른 영역에서는 맞지 않았다. Rust는 시스템 프로그래밍에 필요한 현실적인 제어력과 안전성을 동시에 제공했고, 컴파일러·툴체인·라이브러리 생태계까지 포함해 실제 프로젝트를 끝까지 끌고 갈 수 있는 조건을 갖추고 있었다.

이 과정을 겪으면서 한 가지 확신하게 된 점이 있다. 언어의 생존 여부는 언어 자체의 우열로 결정되지 않는다는 것이다. 어떤 언어가 더 “좋은 언어”인가보다, 그 언어가 어떤 문제를 해결하기 위해 쓰이느냐가 훨씬 중요하다. Haskell은 내가 만들고자 했던 Wave의 최종 형태에는 맞지 않았지만, 그렇다고 해서 쓸모없는 언어가 되는 것은 아니다. 오히려 그 반대다. Haskell은 정확히 자신이 가장 잘할 수 있는 영역에서 지금도 역할을 수행하고 있다.

이 경험은 이후 언어를 바라보는 시선을 완전히 바꿔 놓았다. 특정 언어를 “사라질 언어”라고 부르기 전에, 그 언어가 어디에서, 어떤 문제를 해결하고 있는지를 먼저 봐야 한다. 언어는 경쟁에서 탈락해서 사라지는 게 아니라, 필요가 사라질 때 비로소 사라진다. 그리고 내가 직접 겪은 한, Haskell의 필요는 아직 사라질 기미가 전혀 없어 보인다.

---

## 언어는 기반이 존재하는 한 사라지지 않는다

Objective-C, COBOL, Delphi, Smalltalk, Haskell. 이 다섯 언어의 공통점은 무엇일까. 모두 한때의 유행으로 만들어진 언어가 아니라, 특정 문제를 해결하기 위해 깊게 뿌리내린 언어라는 점이다. 그리고 그 뿌리는 지금도 살아 있다.

Objective-C는 흔히 Swift에 밀려 사라지는 언어처럼 이야기되곤 한다. 하지만 Apple 생태계를 조금만 깊게 들여다보면 이 주장이 얼마나 피상적인지 바로 알 수 있다. Cocoa와 Cocoa Touch의 핵심은 여전히 Objective-C이며, Swift는 그 위에 쌓인 언어에 가깝다. 대규모 기존 코드베이스와 수십 년에 걸쳐 축적된 프레임워크를 단번에 대체하는 일은 현실적으로 불가능하다. Objective-C는 이미 “새 언어”의 경쟁에서 이기는 위치에 있는 게 아니라, 기반 언어의 위치에 있다.

COBOL은 늘 “곧 사라질 언어”의 대표 주자로 불린다. 하지만 현실 세계에서는 전혀 다른 이야기가 펼쳐진다. 금융과 공공 시스템의 핵심에는 여전히 COBOL이 존재한다. ATM 거래, 신용카드 승인, 은행 내부의 정산 시스템처럼 단 몇 분만 멈춰도 사회 전체에 영향을 미치는 영역에서 COBOL은 지금도 작동 중이다. JPMorgan Chase 같은 글로벌 금융 기관들이 COBOL을 유지하는 이유는 향수가 아니라 안정성과 검증된 신뢰성 때문이다. 이 언어는 조용하지만, 없어지면 바로 문제가 드러나는 언어다.

Delphi 역시 비슷하다. 대중적인 개발 커뮤니티에서는 잘 보이지 않을 뿐, 산업 현장에서는 지금도 꾸준히 사용된다. 데이터베이스 중심의 엔터프라이즈 애플리케이션, 산업 자동화, 의료·물류 시스템 등에서는 안정성과 생산성이 무엇보다 중요하다. Delphi는 이 영역에서 오랫동안 신뢰를 쌓아온 도구다. 눈에 띄지 않는다는 이유로 사라진 언어 취급을 받기에는, 여전히 너무 많은 시스템이 이 언어 위에서 돌아가고 있다.

Smalltalk은 프로그래밍 언어 역사에서 빼놓을 수 없는 존재다. 순수 객체지향이라는 개념 자체가 이 언어에서 출발했다. 흥미로운 점은, Smalltalk이 단지 교과서 속 언어로만 남아 있는 것이 아니라는 사실이다. 금융, 물류, 반도체 장비 제어 같은 고도로 복잡하고 안정성이 요구되는 영역에서 Smalltalk는 지금도 핵심 로직을 담당하고 있다. JPMorgan Chase가 복잡한 금융 파생상품 시스템에 Smalltalk를 사용하며 생산성을 높였다는 사례는, 이 언어가 단순한 역사적 유물이 아님을 잘 보여준다.

---

## Haskell이 사라질 언어라는 주장에 대하여

이 목록에서 가장 이해가 되지 않는 선택은 단연 Haskell이다.
Haskell을 “사라질 언어”로 분류하는 시선은, 이 언어가 어떤 문제를 해결하기 위해 만들어졌는지를 완전히 놓치고 있다고 느껴진다. Haskell은 애초에 대중적인 범용 언어를 목표로 한 적이 없다. 웹 프레임워크 경쟁이나 스타트업 생산성을 위한 언어가 아니었고, 빠른 시장 점유율을 염두에 둔 언어도 아니었다. Haskell은 처음부터 수학적 정확성과 추론 가능성을 가장 중요한 가치로 삼은 언어였다.

이 점이 바로 Haskell이 자주 오해받는 이유이기도 하다. 많은 사람들이 언어의 성공을 “얼마나 많은 사람들이 쓰느냐”로 판단한다. 하지만 Haskell은 애초에 그런 경쟁에 참여하지 않았다. 대신, 오류를 최대한 컴파일 타임으로 끌어올리고, 프로그램의 동작을 수학적으로 추론 가능하게 만드는 데 집중해 왔다. 이 철학은 지금도 변하지 않았고, 그렇기 때문에 Haskell은 특정 영역에서 꾸준히 선택되고 있다.

Haskell이 컴파일러와 언어 구현 분야에서 자주 등장하는 이유도 여기에 있다. Elm 컴파일러를 비롯해 여러 언어 구현체가 Haskell로 작성되었고, 컴파일러 연구나 정적 분석, 타입 이론 분야에서는 여전히 중요한 위치를 차지한다. 이는 단순히 “함수형 언어라서”가 아니라, 언어 자체가 추론과 검증을 전제로 설계되어 있기 때문이다. 실제로 Rust의 초기 컴파일러가 Haskell은 아니지만 같은 함수형 언어인 OCaml로 작성되었다는 사실도, 이 흐름을 잘 보여준다.

금융권에서의 Haskell 활용은 이 언어의 성격을 가장 극단적으로 드러내는 사례다. 금융 시스템에서 런타임 오류는 단순한 버그가 아니라, 곧바로 수백만 달러의 손실로 이어질 수 있다. 이런 환경에서는 “빨리 개발하는 언어”보다 “틀릴 가능성이 낮은 언어”가 더 큰 가치를 가진다. Haskell의 강력한 타입 시스템과 함수형 패러다임은 이 지점에서 실질적인 힘을 발휘한다. 이 때문에 일부 금융 기관들은 여전히 Haskell을 리스크 분석, 트레이딩 시스템, 모델 검증에 사용하고 있다.

블록체인 분야에서도 비슷한 이유로 Haskell이 선택된다. Cardano는 신뢰성과 수학적 검증을 핵심 가치로 삼은 프로젝트이고, 그 철학에 가장 잘 맞는 언어 중 하나로 Haskell을 선택했다. 이는 단순한 취향의 문제가 아니라, 시스템의 성격과 언어의 철학이 정확히 맞아떨어진 결과다.

결국 Haskell은 유행하지 않는 언어일 뿐, 역할을 잃은 언어가 아니다. 오히려 역할이 너무 분명하기 때문에 대중적인 위치에 오르지 않았다고 보는 편이 더 정확하다. 모든 언어가 범용일 필요는 없고, 모든 언어가 대중적일 필요도 없다. Haskell은 애초에 “많은 사람이 쓰는 언어”가 아니라, “틀리면 안 되는 곳에서 쓰는 언어”로 자리 잡았다.

그런 언어를 두고 사라질 언어라고 말하는 것은, 언어의 생존을 유행과 혼동한 결과에 가깝다. Haskell은 지금도, 그리고 앞으로도 필요로 하는 곳에서 조용히 살아남을 언어다.

---

## 언어는 유행으로 만들어지지 않는다

대부분의 프로그래밍 언어는 유행을 좇아 만들어지지 않는다. 오히려 그 반대에 가깝다. 현실에서 마주한 아주 구체적인 문제 하나를 해결하기 위해 태어나고, 그 문제를 해결하는 과정에서 언어의 성격과 철학이 굳어진다. C가 Unix를 만들기 위해 탄생한 것은 유명한 이야기다. 운영체제를 직접 구현할 수 있을 만큼 하드웨어에 가깝고, 동시에 어셈블리보다는 생산성이 높은 언어가 필요했기 때문에 C가 만들어졌다. 그리고 그 선택은 결과적으로 수십 년을 버텨낸 언어를 만들어냈다.

Java 역시 처음부터 지금 우리가 아는 모습으로 설계된 언어는 아니었다. Java의 전신인 Oak는 서버 시장을 지배하기 위해 만들어진 언어가 아니라, 다양한 가전제품과 임베디드 환경에서 돌아갈 수 있는 범용 언어를 목표로 했다. 당시에는 “한 번 작성하면 어디서든 실행된다”는 개념 자체가 실험적인 발상이었고, 인터넷과 웹의 폭발적인 성장이라는 외부 환경이 Java의 운명을 완전히 바꿔 놓았다. 결과적으로 Java는 서버, 엔터프라이즈, 금융, 대규모 분산 시스템의 핵심 언어로 자리 잡았지만, 그 출발점은 지금의 모습과는 상당히 달랐다.

Rust도 마찬가지다. Rust는 처음부터 대규모 상업 언어로 기획된 프로젝트가 아니었다. 개인 프로젝트로 출발해, 메모리 안전성과 동시성 문제를 근본적으로 해결하려는 시도에서 시작되었다. 이후 Mozilla의 Servo 프로젝트에 사용되면서 언어는 급격히 성장했고, “안전하지만 빠른 시스템 프로그래밍 언어”라는 명확한 정체성을 얻게 됐다. 중요한 점은, Rust가 C나 C++을 대체하겠다는 거대한 슬로건에서 출발한 것이 아니라, 기존 언어들이 반복적으로 실패하던 지점을 해결하려는 실용적인 문제의식에서 시작됐다는 것이다. 그리고 바로 그 지점이 Rust를 오래 살아남게 만든 핵심 요소라고 생각한다.

이런 사례들을 보면 공통점이 분명해진다. 처음부터 거대한 생태계나 시장 지배를 목표로 설계된 언어보다, 특정 문제를 정확히 겨냥해 만들어진 언어가 오히려 시간이 지나면서 더 단단해진다. 문제는 사라지지 않고, 문제를 정확히 해결한 언어 역시 함께 살아남기 때문이다.

물론 정의를 어떻게 내리느냐에 따라 “사장된 언어”는 존재할 수 있다. 만약 언어의 생존을 대규모 채용 시장이나 상업적 수익, 혹은 대중적인 인지도만으로 판단한다면 Prolog나 Smalltalk 같은 언어는 이미 주류에서 밀려난 것처럼 보일 수도 있다. 하지만 그것은 언어가 죽었다기보다는, 무대가 바뀌었다고 보는 편이 훨씬 정확하다. 여전히 특정 분야에서는 대체 불가능한 가치를 제공하고 있고, 그 언어를 필요로 하는 사람들은 지금도 존재한다.

결국 프로그래밍 언어의 생존 여부는 인기 투표로 결정되지 않는다. 언어는 유행이 아니라 필요의 총합으로 남는다. 그리고 그 필요가 완전히 사라지지 않는 한, 언어 역시 쉽게 사라지지 않는다.

---

## Wave를 만들며 다시 생각하게 된 언어의 의미

내가 Wave를 개발하게 된 과정도 이 맥락과 크게 다르지 않다. 처음부터 새로운 프로그래밍 언어를 만들겠다는 목표가 있었던 것은 아니다. 고등학생 시절 AAA급 게임을 기획하면서, 언리얼 엔진 5와 Source 2를 놓고 고민했다. 하지만 프로젝트의 스케일과 구조를 감당하기에는 기존 엔진으로는 기술적인 한계가 명확했다. 그래서 엔진을 직접 만들기로 결정했고, 그 과정에서 언어 자체의 구조적 제약에 부딪히게 됐다.

결국 문제의 뿌리는 엔진이 아니라 언어에 있다는 결론에 도달했고, 그렇게 Wave가 시작됐다. 지금의 Wave는 FFI를 준비 중이고, raylib 같은 게임 라이브러리를 바인딩할 계획도 가지고 있다. 이 과정에서 다시 한 번 느낀 것은, 언어는 “대체되는 대상”이 아니라 “필요에 따라 태어나는 도구”라는 사실이다.

---

## 결국, 언어는 쉽게 사라지지 않는다

우리는 주류 언어를 쓰기도 하고, 마이너한 언어를 쓰기도 한다. 중요한 것은 그 언어가 지금도 누군가의 문제를 해결하고 있는가다. 그리고 만약 그 언어가 오픈소스라면, 한 번쯤은 기여해보는 것도 나쁘지 않다고 생각한다. 자기가 쓰는 언어에 애정을 쏟는 행동, 그 자체가 프로그래밍을 진짜로 좋아한다는 증거일지도 모른다.

“미래에 없어질 프로그래밍 언어”라는 말은 쉽게 던질 수 있다. 하지만 실제 세계를 지탱하는 수많은 시스템을 생각해보면, 언어는 생각보다 훨씬 끈질기게 살아남는다. 그리고 어쩌면, 사라지는 것은 언어가 아니라 우리가 그 언어를 바라보는 시선일지도 모른다.