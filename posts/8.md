---
title: "Succinct Data Structures란 무엇인가"
date: "2026-01-01"
---

우리가 흔히 사용하는 자료구조들을 떠올려보자. 트리, 그래프, 트라이, 문자열 인덱스 같은 구조들이다. 이 자료구조들은 형태는 서로 달라도 내부를 뜯어보면 공통된 특징을 하나 가지고 있다. 바로 포인터 기반 구조라는 점이다.

```text
Node {
    left: *Node
    right: *Node
}
```

이 포인터는 구조를 표현하는 데 매우 직관적이다. 하지만 비용이 크다.
64비트 환경에서 포인터 하나는 8바이트를 차지한다. 트리 노드 하나에 포인터가 2개만 있어도 16바이트다. 여기에 노드 자체의 데이터, 정렬 패딩, allocator 오버헤드까지 합치면 실제로는 노드 하나당 수십 바이트가 소모된다.

중요한 점은 여기다.
우리가 진짜 저장하고 싶은 정보는 노드의 값인데, 구조를 유지하기 위한 비용이 그보다 더 커진다.

노드 수가 수백만 개 단위를 넘어가면 이 문제는 단순한 메모리 낭비를 넘어서 캐시 효율 저하로 이어진다. 포인터는 메모리 상에서 흩어져 있고, 이는 CPU 캐시 친화적이지 않다. 결국 메모리는 남아 있는데 성능은 떨어지는 기묘한 상황이 발생한다.

---

## “그럼 압축하면 되지 않나?”라는 생각의 한계

이쯤 되면 자연스럽게 이런 생각이 든다.
“어차피 구조가 메모리를 많이 먹으니, 그냥 압축하면 되는 거 아닌가?”

하지만 압축은 만능 해결책이 아니다. 압축의 본질은 데이터를 연속적인 비트열로 바꾸는 것이다. 그 대가로 무엇을 포기하느냐 하면, 직접 접근성이다.

압축된 데이터에서는 `tree[i].left` 같은 접근이 불가능하다. 특정 위치의 정보를 얻기 위해서는 앞부분을 해석하거나, 전체를 디코딩해야 한다. 즉, 접근 비용이 커진다. 압축 포맷이 강력할수록 이 문제는 더 심해진다.

정리하면 이렇다.
압축은 저장에는 유리하지만, 자료구조가 요구하는 빠른 랜덤 접근과는 근본적으로 맞지 않는다.

---

## Succinct Data Structures가 던지는 질문

Succinct Data Structures는 이 지점에서 정면 돌파를 시도한다.

“압축된 상태를 유지하면서, 포인터 기반 자료구조처럼 빠르게 접근할 수는 없을까?”

이 질문이 말이 안 되는 이유는 명확하다.
압축은 순차 접근에 유리하고, 자료구조는 랜덤 접근에 유리하다. 이 둘은 서로 정반대 방향을 바라보고 있다. Succinct는 이 모순을 회피하지 않고, 오히려 수학적으로 밀어붙인다.

---

## 정보 이론적 하한이라는 절대선

Succinct를 이해하려면 정보 이론을 빼놓을 수 없다.
예를 들어 길이가 `n`인 비트열이 있고, 그중 `1`이 정확히 `k`개 있다고 하자. 이 정보를 표현하는 데 필요한 최소 비트 수는 다음과 같다.

```text
log₂ (n choose k)
```

이 값은 “이론적으로 가능한 최소치”다. 이보다 적은 비트로 표현하는 것은 불가능하다. 이는 구현의 문제가 아니라 수학적으로 증명된 한계다.

Succinct Data Structures의 목표는 이 하한선에 최대한 근접하는 것이다. 정확히 말하면,

`이론적 하한 + o(n)`

여기서 o(n)은 n이 커질수록 상대적으로 무시할 수 있는 추가 공간을 의미한다. 즉, 데이터 크기가 커질수록 구조 오버헤드는 사실상 사라지는 수준을 목표로 한다.

---

## Bit Vector: 모든 구조의 출발점

Succinct 구조의 핵심 재료는 Bit Vector다.

```text
B = 1 0 1 0 0 1 0 1 1 0 0 1
```

Bit Vector는 “0/1만 있는 배열”로 끝나는 개념이 아니다. Succinct에서는 Bit Vector가 구조를 표현하는 메타 언어가 된다. 포인터로 연결하던 관계를, 비트 패턴과 위치로 표현한다. 그래서 Bit Vector를 “읽는 방법”이 같이 따라온다.

예를 들어, 경계(boundary)를 Bit Vector로 표현하는 방식이 있다. 문자열 여러 개를 하나의 큰 배열에 붙여 저장하고, 각 문자열의 시작 위치만 Bit Vector로 표시한다.

```text
문자열들:   "cat", "dog", "ox"
연속저장:   c a t d o g o x
인덱스:     0 1 2 3 4 5 6 7

시작표시 S: 1 0 0 1 0 0 1 0
```

이런 표현이 있으면 “k번째 문자열의 시작 위치” 같은 질의를 select로 바로 얻는다.

또 다른 전형은 “구간 시작/끝” 같은 이벤트를 Bit Vector로 표현하는 방식이다.

```text
시간축 인덱스: 0 1 2 3 4 5 6 7 8 9
이벤트 시작:   0 1 0 0 1 0 0 0 0 1
```


여기서 “지금까지 시작한 이벤트 수”는 rank로 바로 구한다. 이런 식으로 Bit Vector는 존재/경계/구간 같은 구조 정보를 담는다.

정리하면, Succinct에서 Bit Vector는 “데이터”이면서 “인덱스”다. 그래서 Bit Vector 위에서 빠른 연산이 필수다. 그 빠른 연산의 중심이 rank/select다.

---

## Rank 연산이 의미하는 것

`rank(bit, i)`는 인덱스 `i`까지 특정 비트가 몇 번 등장했는지를 의미한다.

```text
B = 1 0 1 0 0 1 0 1
rank(1, 7) = 4
```

rank는 prefix sum이다. Bit Vector를 누적합 배열처럼 다룬다. 예시로 `rank1(i)`를 실제로 펼치면 이런 형태가 된다.

```text
i:        0 1 2 3 4 5 6 7
B[i]:     1 0 1 0 0 1 0 1
rank1(i): 1 1 2 2 2 3 3 4
```

이 표가 의미하는 건 “i 위치가 전체에서 어느 정도 진행됐는지”가 숫자로 나온다는 거다. 이게 구조를 만들 때 매우 강력하다.

예를 들어, Bit Vector가 “시작 위치 표시”였다면, rank는 “현재 인덱스가 몇 번째 블록/문자열/노드에 속하는지”를 알려준다.

```
S = 1 0 0 1 0 0 1 0
i = 5일 때 rank1(5) = 2

해석: 인덱스 5는 '두 번째 시작점 이후'에 있다
즉, 0번째 시작(인덱스0)과 1번째 시작(인덱스3) 다음 구간에 속한다
```

그래서 rank는 “위치 → 논리적 번호”로 바꾸는 연산이다. 이게 트리/트라이/인덱스 구조에서 노드 번호를 계산하는 핵심 도구가 된다.

---

## Select 연산이 의미하는 것

`select(bit, k)`는 `k`번째 `bit`가 정확히 어디에 있는지를 알려준다.

```text
select(1, 3) = 5
```

select는 “논리적 번호 -> 위치”로 되돌리는 연산이다. 1의 위치들을 나열해보면 select가 뭘 하는지 바로 보인다.

```text
B = 1 0 1 0 0 1 0 1
1의 위치들 = [0, 2, 5, 7]

select(1, 1) = 0
select(1, 2) = 2
select(1, 3) = 5
select(1, 4) = 7
```

select는 “k번째 시작점”, “k번째 노드의 오픈 괄호 위치”, “k번째 자식 블록의 시작” 같은 걸 바로 찾아준다. 즉, 구조가 Bit Vector로 표현될 때, select는 포인터처럼 동작한다.

rank와 select가 같이 있으면 왕복 변환이 된다.

```text
위치 i -> rank로 논리 번호로 바꿈
논리 번호 k -> select로 실제 위치로 복귀
```

그래서 “비트열 위에 논리적 좌표계”가 생긴다. Succinct 구조는 이 좌표계를 기반으로 트리와 인덱스를 만든다.

---

## 말도 안 되는 요구사항의 정체

Succinct Data Structures는 다음 두 조건을 동시에 요구한다.

rank와 select 연산은 O(1)이다.
이를 위해 추가로 사용하는 메모리는 o(n)이다.

여기서 o(n)은 “n에 비해 무시되는 수준”을 말한다. 대충 감을 잡기 위해 숫자로 보면 이런 느낌이다.

```text
n = 1,000,000,000 (10억 비트)
n 비트 = 약 125MB

o(n) = n에 비례하지 않는 추가 공간
예: n / log n, n / (log n)^2 같은 급으로 줄어드는 오버헤드
```

핵심은 “rank/select를 빠르게 하려고 보조 정보를 저장하되, 그 보조 정보가 원본 크기와 같은 급으로 커지면 Succinct가 아니다”다. 보조 정보는 커져도 되는데, 성장률이 원본보다 느려야 한다.

---

## 블록 분할이라는 해결 전략

해결책은 계층화다. Bit Vector를 큰 블록과 작은 블록으로 나눈다. 큰 블록마다 “여기까지의 1의 개수”를 저장한다. 작은 블록은 더 촘촘하게 누적값을 저장하거나, 더 작은 단위는 테이블을 사용한다.

구조는 보통 이런 3단 구성이 된다.

```text
[Superblock]  아주 큼  -> 여기까지 rank 저장
  [Block]     중간    -> superblock 내부 보정용 rank 저장
    [Tiny]    매우 작음 -> 모든 패턴에 대한 rank를 테이블로 즉시 계산
```

실제로 rank(1, i)를 계산하는 흐름은 이렇게 된다.

```text
rank(1, i)
= super_rank[super_id]
+ block_rank[block_id]
+ tiny_table[tiny_pattern][offset]
```

여기서 `tiny_pattern`은 작은 비트 구간의 실제 비트 패턴이다. tiny 구간이 충분히 작으면 가능한 패턴 수가 제한된다. 예를 들어 tiny가 8비트면 패턴 수는 256개다. 테이블은 고정 크기다.

```text
tiny가 8비트일 때:
패턴 수 = 2^8 = 256
offset은 0..7

table[256][8]이면 모든 패턴/위치의 rank를 미리 들고 있는 셈이다
```

이 방식의 결과는 명확하다.

```text
- 큰 배열을 끝까지 세지 않는다
- 몇 번의 배열 접근으로 끝낸다
- 반복문이 없다
- 상수 시간이다
```

select는 rank보다 구현이 더 까다로운 편인데, 핵심 방식은 비슷하다. “k번째 1이 어느 블록에 들어있는지”를 상위 요약정보로 빠르게 좁히고, 마지막에 작은 블록에서 찾는다.

---

## Succinct Tree: 포인터 없는 트리

이제 이 개념을 트리에 적용한다. Succinct Tree의 핵심 아이디어는 트리를 괄호열로 표현하는 것이다.

DFS로 트리를 순회하면서 노드에 진입할 때 `(`, 노드를 빠져나올 때 `)`를 기록한다.

```text
(()(()()))
```

이 괄호열은 트리 구조를 완전히 담고 있다. 이걸 `(`는 1, `)`는 0으로 바꾸면 Bit Vector가 된다.

```text
P = ( ( ) ( ( ) ( ) ) )
B = 1 1 0 1 1 0 1 0 0 0
```

여기서 트리 연산이 가능한 이유는 “깊이(depth)”가 괄호열의 prefix 성질로 계산되기 때문이다. 보통 `excess`라는 개념으로 설명한다.

```text
'('를 +1, ')'를 -1로 본다
excess(i) = 0..i까지의 합

depth(노드의 '(' 위치) = excess(그 위치)
```

예시로 excess를 적어보면 구조가 눈에 보인다.

```text
P:        ( ( ) ( ( ) ( ) ) )
value:    +1+1-1+1+1-1+1-1-1-1
excess:    1 2 1 2 3 2 3 2 1 0
```

여기서 중요한 사실이 나온다.

- 어떤 노드의 서브트리는 “그 노드의 `(`부터 매칭되는 `)`까지의 구간”이다.
- 깊이는 excess로 계산된다.
- 부모는 “현재 노드의 `(`보다 앞에 있으면서 depth가 정확히 1 작은 가장 가까운 `(`”로 정의된다.

이 연산들을 빠르게 하려면 “매칭 괄호 찾기(find close/open)”, “특정 depth로 이동(enclose)” 같은 primitive가 필요하다. 이 primitive들은 rank/select와 추가적인 보조 구조(RMQ 계열)로 O(1)에 만든다. 구현 난이도가 여기서 확 올라간다.

결과적으로 부모 노드, 첫 번째 자식, 서브트리 크기, 노드 깊이 같은 연산들이 포인터 없이 계산된다. 시간 복잡도는 O(1)이다.

---

## Succinct Trie와 문자열 처리

Trie는 메모리 사용량이 큰 구조다. 문자 배열과 포인터가 결합되면 노드 수가 늘어날 때 메모리 비용이 폭증한다. 그래서 대규모 사전, 자동완성, 형태소 사전 같은 영역에서 Trie는 곧바로 메모리 병목이 된다.

Succinct Trie는 트리의 형태를 Bit Vector로 표현하고, 문자(간선 라벨)는 연속 배열로 저장한다. 대표적인 표현 중 하나가 LOUDS(Level-Order Unary Degree Sequence)다. 레벨 순서로 각 노드의 자식 수를 unary로 적고 0으로 구분한다.

간단한 예시를 하나 든다.

```text
루트의 자식 2개
첫째 자식의 자식 1개
둘째 자식의 자식 0개
그 다음 노드의 자식 0개

degree: 2, 1, 0, 0
LOUDS:  11 0 1 0 0 0 0
        1 1 0 1 0 0 0 0
```

여기서 노드 번호와 자식 구간의 매핑이 rank/select로 계산된다.

```text
- 어떤 노드의 "첫 자식 위치"는 select(0, node_id) 기반으로 계산한다
- 자식들의 범위는 연속 구간이다
- 그 구간에서 k번째 자식은 offset으로 바로 이동한다
```

이 구조는 “자식 배열이 연속 구간”으로 떨어지기 때문에 캐시 효율도 좋다. 포인터 트라이는 메모리가 흩어지는데, Succinct Trie는 배열 중심 구조라서 순회가 빠르다.

---

## FM-Index: 압축과 검색의 공존

FM-Index는 Succinct Data Structures의 대표 주제다. 문자열을 Burrows–Wheeler Transform(BWT)으로 변환한 뒤 압축하면서도, 그 상태에서 substring 검색을 지원한다.

FM-Index의 검색은 “뒤에서부터 한 글자씩 매칭하는 방식”으로 진행된다. 핵심은 매칭 후보 범위를 [l, r] 구간으로 유지하고, 다음 글자를 붙일 때마다 구간을 갱신하는 방식이다. 이 구간 갱신에 rank(Occ)가 들어간다.

전형적인 업데이트 형태는 이런 식이다.

```text
l' = C[c] + Occ(c, l-1) + 1
r' = C[c] + Occ(c, r)
```

여기서

```text
C[c] = 문자 c보다 사전순으로 작은 문자들의 총 개수
Occ(c, i) = BWT에서 0..i까지 문자 c가 몇 번 나왔는지
```

Occ가 바로 rank 문제다. 문자가 비트가 아니니, 실제 구현에서는 “문자별 bitvector” 또는 “wavelet tree” 같은 구조로 Occ를 rank처럼 처리한다. 어쨌든 중심은 rank다.

작동 감각은 이렇다.

```text
- 처음에는 전체 구간이 후보이다
- 패턴의 마지막 글자부터 시작한다
- rank로 후보 구간을 계속 좁힌다
- 구간이 비면 매칭 실패다
- 구간 크기가 매칭 개수다
```

그래서 FM-Index는 “압축된 상태에서 검색”이 된다. DNA 서열 검색, 대용량 로그 분석 같은 곳에서 이 방식이 강력하게 먹힌다. 데이터가 너무 커서 “풀어서 검색” 자체가 비용이 되기 때문이다.

---

## 왜 대부분의 개발자는 이걸 접하지 못할까

이 글을 읽는 대부분의 개발자는 웹 개발자일 가능성이 높다. 웹 개발자라는 직군 자체가 나쁘다는 뜻은 아니다. 다만 웹 개발이라는 영역에서는 Succinct Data Structures를 직접 구현하거나, 내부 구조를 깊이 들여다볼 일이 거의 없다.

하지만 이 글을 쓰는 나는 웹 개발자가 아니다. 나는 프로그래밍 언어와 컴파일러를 만들고, 운영체제와 시스템 레벨의 구조를 다루는 개발자다. 메모리 레이아웃, 캐시 효율, 데이터 표현 방식 같은 문제는 나에게 이론이 아니라 현실적인 제약 조건이다.

그래서 이 구조를 “알면 좋은 지식”이 아니라, “존재를 이해하지 않으면 시스템의 한계를 설명할 수 없는 기술”로 접하게 된다.

웹 개발자들은 보통 검색엔진, 데이터베이스, 브라우저 엔진 같은 시스템을 사용하는 쪽에 있다. 반면 Succinct Data Structures는 그 시스템의 내부를 구성하는 쪽의 기술이다. 검색이 빠른 이유, 인덱스가 메모리를 적게 쓰는 이유, 대규모 문자열 처리가 가능한 이유는 대부분 이 계열의 구조에 있다.

Succinct Data Structures는 보이지 않는 곳에서 시스템의 한계를 밀어내고 있다.

---

## 이 분야가 어려운 진짜 이유

Succinct Data Structures가 어려운 이유는 단순히 복잡해서가 아니다. 비트 단위 설계, 캐시 라인과 메모리 접근 패턴, 조합론과 엔트로피 같은 수학 개념, 논문에서 코드로 바로 이어지는 구현 난이도까지 전부 요구된다.

알고리즘, 시스템, 수학 이 세 가지가 동시에 필요하다. 그래서 이 분야는 어렵고, 그래서 깊다.