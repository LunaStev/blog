---
title: "트리 알고리즘에 대해서 알아보자"
description: "트리 알고리즘에 대해서 자세히 알아보자."
date: "2025-12-31"
---

트리(Tree)는 계층 구조를 표현하는 자료구조다. 하나의 루트(Root)에서 시작해서 부모에서 자식으로 이어지는 구조를 가진다. 위에서 아래로 가지가 뻗어나가는 나무의 형태를 떠올리면 이해하기 쉽다.

![7_1](/image/7_1.png)

트리는 그래프와 자주 비교되지만 중요한 차이가 있다. 트리는 사이클이 없다는 점이다. 다시 말해, 어떤 노드에서 출발해 다시 자기 자신으로 돌아오는 경로가 존재하지 않는다. 이 특징 덕분에 트리는 구조가 명확하고, 흐름이 한 방향으로 정리된다.

이 성질 때문에 트리는 “위계가 분명한 구조”를 표현하는 데 최적화된 자료구조다. 조직도, 파일 시스템, UI 구조처럼 위아래 관계가 명확한 대상은 대부분 트리로 모델링할 수 있다.

---

## 트리의 기본 용어 이해하기

트리를 제대로 다루기 위해서는 몇 가지 기본 용어를 반드시 이해해야 한다. 이 용어들은 이후에 나오는 모든 트리 알고리즘의 공통 언어다.

- Node는 트리를 구성하는 하나의 데이터 단위다. 트리는 결국 노드들의 집합이라고 볼 수 있다.
- Root는 트리의 가장 위에 위치한 노드이며, 모든 노드는 루트로부터 시작해 연결된다.
- 부모와 자식은 노드 간의 직접적인 상하 관계를 의미한다.
- Leaf는 자식 노드를 가지지 않는, 트리의 끝에 위치한 노드다.
- Subtree는 트리의 특정 노드를 기준으로 잘라낸 부분 트리를 말한다.
- Depth는 루트에서 특정 노드까지 몇 단계를 거쳐 왔는지를 의미한다.
- Height는 루트에서 가장 깊은 리프 노드까지의 거리다.

이 용어들은 트리 구조를 사고하는 기준점이라고 보면 된다.

---

## 트리는 왜 중요한가

트리는 현대 소프트웨어의 핵심 구조 중 하나다.

우리가 작성하는 프로그램은 결국 프로그래밍 언어로 표현된다. 그런데 이 프로그래밍 언어는 내부적으로 문자열 상태로 처리되지 않는다. 소스 코드는 파싱 과정을 거쳐 트리 구조로 변환되고, 이 트리를 기반으로 분석과 변환이 이루어진다. 이때 사용되는 것이 AST(Abstract Syntax Tree)다.

컴파일러나 인터프리터에서 문법 분석, 타입 검사, 최적화, 코드 생성은 전부 트리를 순회하고 변형하는 작업이다. 즉, 프로그래밍 언어의 중심에는 항상 트리가 있다.

이뿐만 아니라 파일 시스템의 디렉토리 구조, UI 컴포넌트 트리, 네트워크 라우팅 구조, 게임 엔진의 씬 그래프, 조직도까지 트리는 거의 모든 시스템에서 등장한다.
그래서 트리를 이해하는 것은 시스템을 이해하는 기초 체력이라고 볼 수 있다.

---

## 트리의 기본 종류

트리는 크게 일반 트리와 이진 트리로 나눌 수 있다.

![7_2](/image/7_2.png)

일반 트리는 자식 수에 제한이 없다. 하나의 노드가 여러 개의 자식을 가질 수 있으며, 구조가 자유롭다. 파일 시스템이나 AST처럼 현실 세계의 구조를 그대로 반영해야 하는 경우에 적합하다.

이진 트리는 각 노드가 최대 두 개의 자식만 가질 수 있다. 보통 왼쪽(left)과 오른쪽(right)으로 구분한다. 이 제한 덕분에 다양한 성질을 가지게 되고, 이를 활용한 알고리즘들이 만들어진다.

이진 트리는 형태에 따라 다시 분류된다.
- 자식이 없거나 정확히 두 개인 경우를 Full Binary Tree라고 한다.
- 노드가 왼쪽부터 순서대로 채워지는 형태는 Complete Binary Tree다.
- 모든 레벨이 완전히 채워진 경우는 Perfect Binary Tree라고 부른다.

이 구분은 성능과 구현 방식에 직접적인 영향을 준다.

---

## 트리 순회(Traversal)의 의미

트리에서 가장 중요한 개념은 트리 순회(Traversal)다.
트리는 선형 구조가 아니기 때문에, “어떤 순서로 노드를 방문할 것인가”가 알고리즘의 핵심이 된다.

![7_3](/image/7_3.png)

전위 순회(Preorder)는 루트 노드를 먼저 처리한 뒤, 왼쪽과 오른쪽 서브트리를 방문한다. 트리의 구조를 그대로 출력하거나, AST를 직관적으로 확인할 때 유용하다.

```mathematica
Root -> Left -> Right
```

중위 순회(Inorder)는 왼쪽 서브트리를 먼저 방문한 뒤 루트를 처리하고, 마지막으로 오른쪽 서브트리를 방문한다. 이진 탐색 트리에서 중위 순회를 수행하면 결과가 정렬된 순서로 나온다.

```mathematica
Left -> Root -> Right
```

후위 순회(Postorder)는 왼쪽과 오른쪽 서브트리를 모두 처리한 뒤 마지막에 루트를 방문한다. 계산 결과를 모으거나, 메모리를 해제하거나, 컴파일러에서 코드 생성을 할 때 자주 사용된다.

```mathematica
Left -> Right -> Root
```

실제로 컴파일러 구현에서 가장 많이 쓰이는 순회 방식은 이 후위 순회다. 하위 노드를 모두 처리한 뒤 상위 노드를 처리하는 방식이 자연스럽기 때문이다.

---

## 이진 탐색 트리(BST)

이진 탐색 트리(Binary Search Tree, BST)는 이진 트리의 한 종류로, 탐색을 빠르게 하기 위해 명확한 규칙을 가진 구조다.

![7_4](/image/7_4.png)

이 규칙은 단순하다. 왼쪽 서브트리에는 부모 노드보다 작은 값들만 존재하고, 오른쪽 서브트리에는 부모 노드보다 큰 값들만 존재한다.

이 규칙 덕분에 BST는 탐색 과정에서 불필요한 영역을 한 번에 제거할 수 있다. 어떤 값을 찾을 때, 현재 노드보다 값이 작으면 왼쪽으로, 크면 오른쪽으로 내려가면 되기 때문이다. 이상적인 경우에는 매 단계마다 탐색 범위가 절반씩 줄어들어 탐색, 삽입, 삭제 연산을 `O(log n)` 시간 복잡도로 처리할 수 있다.

하지만 BST에는 치명적인 약점이 있다. 트리의 형태가 데이터 입력 순서에 크게 의존한다는 점이다.
예를 들어, 이미 정렬된 데이터가 순서대로 삽입된다면 트리는 한쪽으로만 계속 늘어지게 된다. 이런 경우 BST는 더 이상 트리다운 구조를 유지하지 못하고, 사실상 연결 리스트와 다를 바 없는 형태가 된다.

이 상태에서는 탐색, 삽입, 삭제 모두 `O(n)`이 되어버린다. 즉, BST는 균형이 유지될 때만 빠르고, 균형이 무너지면 그 장점을 완전히 잃는다.

그래서 BST는 개념적으로는 매우 아름답지만, 실제 시스템에서 그대로 사용하기에는 위험한 자료구조다.

---

## 균형 트리의 등장

BST의 가장 큰 문제는 “균형이 자동으로 유지되지 않는다”는 점이다.
이 문제를 해결하기 위해 등장한 것이 균형 트리(Self-Balancing Tree)다.

![7_5](/image/7_5.png)

균형 트리는 삽입이나 삭제가 발생할 때마다 트리의 높이가 한쪽으로 과도하게 치우치지 않도록 스스로 구조를 조정한다. 이때 사용하는 핵심 기법이 회전(rotation)이다. 회전은 노드들의 상대적인 위치를 바꾸어 트리의 균형을 맞추는 연산이다.

대표적인 균형 트리에는 AVL Tree와 Red-Black Tree가 있다.

AVL Tree는 가장 엄격한 균형 조건을 가진 트리다. 각 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 항상 1 이하로 유지되도록 강제한다. 이 덕분에 트리의 높이는 매우 낮게 유지되며, 탐색 성능은 거의 항상 최적에 가깝다.

하지만 그 대가로 구현이 복잡하다. 삽입이나 삭제가 일어날 때마다 여러 경우를 고려해 회전을 수행해야 하고, 회전의 종류도 많다. 이 때문에 AVL Tree는 이론적으로는 훌륭하지만, 실제 구현과 유지보수 비용이 높은 편이다.

Red-Black Tree는 다른 선택을 한다. AVL Tree처럼 엄격하게 높이를 제한하지는 않지만, 몇 가지 규칙을 통해 트리가 너무 한쪽으로 쏠리지 않도록 한다. 이 규칙들은 트리의 색깔(빨강, 검정)을 기준으로 정의되며, 균형을 “완벽하게” 맞추기보다는 “충분히 괜찮은 수준”으로 유지하는 데 초점을 둔다.

이 덕분에 Red-Black Tree는 회전 횟수가 상대적으로 적고, 구현 난이도와 성능 사이의 균형이 좋다. 그래서 실제 표준 라이브러리에서 널리 사용된다. 대표적으로 C++의 `map`, Java의 `TreeMap`이 Red-Black Tree 기반이다.

정리하자면, AVL Tree는 성능을 극한까지 밀어붙인 선택이고, Red-Black Tree는 실용성을 고려한 선택이라고 볼 수 있다.

---

## 힙(Heap) 역시 트리 구조다

힙(Heap)은 이름만 보면 트리와 전혀 다른 자료구조처럼 느껴질 수 있지만, 개념적으로는 분명한 트리 구조다. 정확히는 완전 이진 트리(Complete Binary Tree) 형태를 가진다.

![7_6](/image/7_6.png)

힙의 핵심 목적은 “정렬”이 아니라 우선순위 관리다.
최소 힙(Min Heap)은 부모 노드가 항상 자식 노드보다 작고, 최대 힙(Max Heap)은 부모 노드가 항상 자식 노드보다 크다. 이 규칙 덕분에 최솟값이나 최댓값을 항상 루트에서 즉시 꺼낼 수 있다.

힙은 이진 탐색 트리처럼 모든 값의 순서를 보장하지 않는다. 대신 “가장 중요한 값 하나”를 매우 빠르게 얻는 데 최적화되어 있다. 삽입과 삭제는 `O(log n)`에 수행되며, 최댓값이나 최솟값 조회는 `O(1)`이다.

힙은 내부적으로 배열로 구현되는 경우가 많다. 하지만 이는 구현상의 편의일 뿐이며, 논리적으로는 명확한 트리 구조다. 배열 인덱스를 이용해 부모와 자식 관계를 계산할 수 있기 때문에 포인터 없이도 트리를 표현할 수 있다.

이런 특성 때문에 힙은 우선순위 큐의 구현에 가장 많이 사용된다. 또한 다익스트라 알고리즘처럼 “가장 비용이 작은 노드를 반복적으로 선택해야 하는 알고리즘”, 그리고 운영체제의 프로세스 스케줄러처럼 “중요도가 높은 작업을 먼저 처리해야 하는 시스템”에서도 핵심 자료구조로 활용된다.

---

## 트리 알고리즘과 재귀

트리 알고리즘의 핵심 패턴은 거의 항상 재귀다.
이건 단순히 “편해서” 그런 게 아니라, 트리라는 구조 자체가 재귀적으로 정의되기 때문이다.

트리는 하나의 노드와, 그 노드 아래에 붙어 있는 여러 개의 서브트리로 구성된다. 그리고 이 서브트리들 역시 다시 같은 구조의 트리다. 즉, 트리는 처음부터 끝까지 “자기 자신과 같은 형태의 구조”를 반복해서 포함하고 있다. 이런 구조에서는 반복문보다 재귀가 훨씬 자연스럽다.

이 특성 때문에 트리 알고리즘을 생각할 때는 보통 이렇게 사고한다.
“현재 노드에서 할 일을 정의하고, 나머지는 자식 노드에게 맡긴다.”

이 사고 방식이 그대로 코드로 드러난 것이 바로 DFS다.

```rust
fn dfs(node: &Node) {
    if node.is_none() {
        return;
    }

    dfs(node.left);
    dfs(node.right);
}
```

이 코드는 가장 기본적인 깊이 우선 탐색(DFS)의 형태다.
여기서 중요한 점은 이 함수가 트리 전체를 처리하려고 하지 않는다는 것이다. 이 함수는 오직 “현재 노드 하나”만을 기준으로 동작한다. 그리고 나머지는 왼쪽과 오른쪽 자식에게 같은 일을 재귀적으로 위임한다.

이 패턴이 강력한 이유는, 트리 전체를 순회하는 로직이 아주 작은 단위의 정의로 분해되기 때문이다.
“노드 하나를 처리하는 방법”만 정의하면, 트리 전체를 처리하는 알고리즘이 자연스럽게 완성된다.

전위 순회, 중위 순회, 후위 순회 역시 이 구조에서 크게 벗어나지 않는다. 차이는 단 하나, 현재 노드를 언제 처리하느냐다.

전위 순회는 현재 노드를 먼저 처리한 뒤 자식으로 내려가고,
중위 순회는 왼쪽을 처리한 뒤 현재 노드를 처리하며,
후위 순회는 모든 자식을 처리한 뒤 마지막에 현재 노드를 처리한다.

즉, 순회 방식의 차이는 재귀 구조의 차이가 아니라 처리 순서의 차이일 뿐이다. 이 점을 이해하면 트리 순회는 더 이상 복잡한 개념이 아니다.

그래서 흔히 트리 알고리즘에 대해 “99%는 재귀”라고 말한다. 이 말은 과장이 아니다. 트리의 구조 자체가 재귀를 전제로 만들어져 있기 때문에, 재귀를 쓰지 않는 쪽이 오히려 부자연스러운 경우가 많다.

물론 재귀에는 단점도 있다. 깊이가 매우 깊은 트리에서는 스택 오버플로우가 발생할 수 있고, 함수 호출 비용도 무시할 수 없다. 그래서 실무에서는 스택을 직접 사용하는 반복 구조로 DFS를 구현하는 경우도 있다. 하지만 개념을 이해하고 알고리즘을 설계하는 단계에서는 재귀가 가장 명확한 도구다.

트리를 이해한다는 것은 결국 이 재귀적인 사고 방식을 익힌다는 뜻과 거의 같다.
한 번 이 감각이 잡히면, 트리 알고리즘은 오히려 가장 직관적인 알고리즘으로 느껴지기 시작한다.

---

## 마무리하며

트리는 프로그램 구조를 이해하는 핵심 개념이다.
트리를 이해하면 컴파일러, 운영체제, 게임 엔진, UI 시스템까지 훨씬 깊이 있게 바라볼 수 있다.

처음에는 개념이 많아 보일 수 있지만, 한 번 구조를 이해하면 트리는 오히려 가장 직관적인 자료구조 중 하나다.

앞으로 나오는 많은 알고리즘과 시스템의 기반이 되는 만큼, 트리는 반드시 제대로 짚고 넘어갈 필요가 있다.