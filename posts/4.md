---
title: "C와 C++는 정말 대체될 수 없는가?"
description: "C와 C++의 대체는 정말 이루어질 수 있을까?"
date: "2025-12-23"
---

“C와 C++를 대체하겠다”는 목표를 내건 언어는 생각보다 많다.
Rust는 등장 초기부터 C와 C++를 대체할 수 있는 시스템 언어라는 평가를 받아왔고, Zig는 아예 C와의 호환성을 중요한 설계 목표로 삼았다. D 언어는 명확하게 C++의 대체를 목표로 시작된 언어이며, Go는 C++의 복잡함에 대한 반발에서 탄생했다. Google의 Carbon 역시 “C++의 후계자”라는 표현이 나올 정도로 같은 문제의식에서 출발한 언어다.

이 외에도 C와 C++를 대체하거나, 혹은 최소한 그 영역을 잠식하겠다는 목표를 가진 언어들은 지금 이 순간에도 계속 등장하고 있다.

하지만 이런 시도에 대해 비판적인 시선도 분명히 존재한다.
“C와 C++로 작성된 코드가 얼마나 많은데, 그걸 어떻게 대체하겠다는 거냐?”
라는 반응은 꽤 흔하다. 얼핏 보면 이 주장은 매우 현실적으로 보인다. 실제로 전 세계에는 수십 년 동안 축적된 방대한 C/C++ 코드베이스가 존재한다. 그렇다면 이 모든 코드를 다른 언어로 다시 작성하는 것이 가능할까?

결론부터 말하면, 불가능하다.

---

## C는 '특별한 언어'가 아니다

여기서 먼저 짚고 넘어가야 할 점이 있다.
C와 C++는 컴퓨터가 직접 이해하는 언어도 아니고, 운영체제가 특별히 “이해하는” 언어도 아니다. C 역시 수많은 프로그래밍 언어 중 하나일 뿐이다.

운영체제는 C가 없어도 만들 수 있다. 실제로 Rust만으로 작성된 운영체제도 존재하고, 미국 국방부가 주도해 만든 Ada는 항공기·군사 시스템에 사용될 만큼 신뢰성을 갖춘 언어이며, 이론적으로나 실제적으로 OS 개발이 가능하다. OSDev.org를 보면 Ada뿐만 아니라 D, Go, Pascal, FreeBASIC, 심지어 C#으로도 최소한의 베어본 커널을 만드는 방법이 소개되어 있다.

즉, “C가 없으면 운영체제를 만들 수 없다”는 주장은 사실이 아니다.

---

## 그럼 왜 C가 지배적인 위치를 차지하게 되었을까?

이 질문의 답은 기술적인 우월성보다는 역사적 맥락에 있다.
C는 Unix 운영체제 개발을 목적으로 만들어진 언어다. 당시 운영체제를 만들 수 있는 현실적인 선택지는 어셈블리어뿐이었고, BCPL이나 B 같은 언어가 있긴 했지만 실용성에는 한계가 있었다.

C는 구조가 단순하다. 많은 사람들이 C를 어렵다고 느끼지만, 문법 구조 자체만 놓고 보면 Python, Java, TypeScript보다 훨씬 단순하다. 문제는 단순함의 대가다. 메모리 관리, 안전성, 모든 책임을 프로그래머에게 맡기는 구조 때문에 실제로는 매우 어렵게 느껴진다.

Unix는 대성공을 거두었고, Windows를 제외한 대부분의 현대 운영체제는 Unix 계열이거나 Unix-like 시스템이 되었다. Linux는 엄밀히 말하면 Unix는 아니지만 POSIX 표준을 따르기 때문에 Unix-like로 분류되고, Apple의 운영체제는 BSD 기반의 XNU 커널을 사용한다. 이런 흐름 속에서 C는 자연스럽게 “기반 언어”의 위치를 차지하게 되었다.

---

## 방대한 C/C++ 코드는 어떻게 대체되는가?

다시 처음 질문으로 돌아가 보자.
이렇게 방대한 C/C++ 코드를 Rust나 Zig 같은 언어로 전부 다시 작성할 수 있을까?

정답은 아니다.
대체의 핵심은 재작성(rewrite) 이 아니라 새로운 코드의 선택이다.

새로운 시스템, 새로운 런타임, 새로운 인프라를 만들 때 C/C++ 대신 Rust나 Zig를 선택하는 사례가 늘어나면, 전체 생태계에서 C와 C++의 비중은 자연스럽게 줄어든다.

예를 들어 Docker는 Go로 작성되었다. Go가 존재하지 않았다면 Docker는 C나 C++로 개발되었을 가능성이 매우 높다. 최근 등장하는 JavaScript 런타임 역시 Rust나 Zig로 작성되는 경우가 많다. Bun은 Zig로, Deno는 Rust로 작성되었다. 만약 이 언어들이 없었다면, 이들 역시 C/C++ 기반이 되었을 것이다.

---

## 재작성은 ‘예외적으로’ 일어난다

물론 기존 C/C++ 코드를 Rust나 Zig로 재작성하는 사례도 존재한다.
Windows의 경우 NT 커널 일부 약 36,000라인의 C++ 코드가 Rust로 성공적으로 포팅되었고, 드라이버 영역에서도 Rust 도입이 진행 중이다. Azure 인프라 전반에서도 Rust가 광범위하게 사용되고 있다. 리누스 토르발즈는 Linux에 C++ 도입에는 강하게 반대했지만, Rust에 대해서는 제한적인 도입을 허용했다.

이런 사례들이 의미하는 바는 명확하다.

- 잘 동작하고, 유지보수에 문제가 없는 코드는 굳이 재작성하지 않는다.
- 하지만 보안 문제가 반복되거나 유지보수가 어려운 영역,
- 혹은 당시에는 대안이 없어서 선택했지만 지금은 더 나은 선택지가 있는 영역은 다른 언어로 재작성되거나, 새 코드로 대체된다.

---

## 결론: 대체는 ‘비율의 변화’다

C와 C++는 지난 50여 년간 축적된 인프라 덕분에 단기간 내에 사라지기는 어렵다. 반면 Rust나 Zig는 등장한 지 10년 남짓한, 아직은 비교적 젊은 언어들이다. 하지만 시간이 지나면서 C/C++와 동일한 영역을 커버하거나, 더 나은 대안을 제공하는 언어들이 계속 등장한다면 생태계의 비율은 자연스럽게 변할 수밖에 없다.

“C와 C++는 대체될 수 없다”는 말과
“C와 C++의 비중은 줄어들 수 있다”는 말은 전혀 다른 이야기다.

만약 마이크로소프트가 ‘코드 레드’를 선포하고 Windows 전체를 C와 C++에서 전부 Rust로 재작성하겠다고 선언한다면, 이론적으로는 불가능한 일은 아닐 것이다.

하지만 그렇게 하지 않는 이유는 기술적 한계 때문이 아니라, 그에 따르는 위험 부담이 너무 크기 때문이다. 수십 년간 축적된 거대한 코드베이스를 한 번에 뒤엎는 선택은, 성공보다 실패의 비용이 훨씬 크다.

그래서 현실에서는 전면적인 대체가 아니라, 차근차근 Rust를 도입해 보안이나 안정성 측면에서 위험한 부분부터 재작성하는 방식을 택하고 있다. 이 과정을 보면 C와 C++를 ‘완전히 대체하겠다’기보다는, 위험하고 비효율적인 부분을 더 안전하고 효율적인 방식으로 바꿔 나가는 것이 목적에 가깝다고 볼 수도 있다.

미래는 누구도 단정할 수 없다. 새로운 하드웨어가 등장할 수도 있고, 기존의 상식을 뒤엎는 운영체제나 런타임이 나타날 수도 있다. 그 기반 언어가 반드시 C나 C++일 이유도 없다. 지금은 분명한 과도기다. 새로운 개념과 새로운 선택지가 끊임없이 등장하고 있다.

그래서 “C와 C++를 대체하겠다”는 말을
무모한 주장이나 허황된 이야기로 단정 지어 **비난**할 필요는 없다.
다만 그것이 어떤 방식으로, 어떤 시간 스케일로 가능한지에 대해서는
냉정하고 현실적인 **비판**이 필요하다.

대체는 혁명이 아니라, 시간이 만든 변화이기 때문이다.