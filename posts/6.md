---
title: "프로그래밍 언어를 만들기 위해서는 무엇을 해야하나"
date: "2025-12-28"
---

프로그래밍 언어를 만들기 위해서는 무엇을 해야하냐는 질문에 답을 하려면 생각보다 어렵다. 프로그래밍 언어는 단순히 문법만으로 이루어진 것이 아니라 하나의 생태계로 구성되어 있고, 그 언어로 어떤 문제를 해결하려는지가 가장 중요하기 때문이다. 그래서 이 질문은 “문법을 어떻게 만들까?”가 아니라 “왜 이 언어가 필요한가?”에서부터 시작해야 한다.

프로그래밍 언어를 만들기 위해 가장 먼저 해야 할 일은 문법을 설계하는 것이 아니라, 왜 프로그래밍 언어를 만들려고 하는지에 대한 이유를 스스로에게 묻는 것이다. 어떤 문제가 존재하고, 그 문제가 기존 언어로는 비효율적이거나 불편하며, 이 언어를 만들면 그 문제를 더 잘 해결할 수 있을 것이라는 확신이 있어야 한다. 단순히 언어를 만들고 싶다는 동기만으로는 끝까지 가기 어렵다.

예를 들면 C와 C++가 불편해서, Rust가 너무 엄격해서, 특정 도메인인 운영체제나 게임, 네트워크에 특화된 언어를 만들고 싶어서일 수도 있다. 혹은 내가 생각하는 이상적인 언어가 머릿속에 있거나, 단순히 유행하는 밈을 언어로 표현해보고 싶다는 가벼운 이유일 수도 있다. 이유의 무게는 중요하지 않지만, 이유 자체는 반드시 명확해야 한다.

여기서 분명히 짚고 가야 할 점이 하나 있다. 언어는 그냥 도구일 뿐이다. C가 없어도 운영체제를 만들 수 있고, Java나 PHP, JavaScript, C#, Ruby, Python이 없어도 웹 백엔드를 만들 수 있다. Python과 C++ 없이도 AI는 만들 수 있고, C++이나 Rust 없이도 게임 엔진을 개발할 수 있다. 결국 어떤 언어를 쓰느냐보다 중요한 것은 목적에 맞게 문제를 해결하느냐이다.

그럼에도 불구하고 우리는 왜 특정 영역에서 특정 언어를 쓰도록 강요받는 걸까. 왜 백엔드는 Java나 Spring을 떠올리고, 프론트엔드는 JavaScript를 기본으로 생각하며, AI 하면 Python이 먼저 떠오를까. 그 이유는 단순하다. 이미 그 언어들이 해당 목적에 가장 적합한 생태계를 만들어 놓았기 때문이다. Java는 오랜 시간 동안 대규모 서버 환경에서 검증된 안정성과 풍부한 프레임워크를 갖췄고, JavaScript는 브라우저라는 독점적인 실행 환경을 기반으로 프론트엔드 표준이 되었다. Python은 문법이 단순하고 수많은 수치 계산 및 머신러닝 라이브러리를 보유하고 있어 연구와 실험에 매우 적합하다. 즉, 언어 자체의 성능이나 문법보다도, 그 언어를 둘러싼 생태계가 선택의 이유가 되는 경우가 대부분이다.

---

## 목적이 정해졌다면, 그 다음은 선택이다

언어의 목적이 정해졌다면 이제 그 목적에 맞는 기능들을 선택해야 한다. 타입 추론을 넣을 것인지, GC를 사용할 것인지, 포인터나 메모리에 직접 접근하게 할 것인지, 타입을 반드시 명시하게 할 것인지, 안전성과 성능 중 무엇을 더 우선할 것인지, 문법은 C 스타일로 갈지 ML 계열 스타일로 갈지, 아니면 완전히 새로운 문법을 만들지 등을 결정해야 한다.

이 단계에서 가장 흔한 실수는 모든 것을 한 번에 넣으려는 것이다. 처음부터 완벽한 언어를 만들겠다는 생각은 거의 항상 실패로 이어진다. 이유는 단순하다. 기능이 많아질수록 구현 난이도는 기하급수적으로 올라가고, 실제로 그 기능이 필요한지 검증할 기회조차 없기 때문이다. 언어는 설계 문서로 완성되는 것이 아니라, 실제로 사용해보면서 다듬어지는 것이다.

그래서 하나씩 만들어가는 것이 중요하다. 처음에는 단순한 선택을 하고, 실제로 언어를 써보면서 이 기능이 정말 필요한지, 아니면 다른 선택이 더 나았는지를 판단하면 된다. 예전에 내렸던 결정이 지금은 틀렸다고 느껴진다면 바꿔도 아무 문제 없다. 언어는 살아 있는 프로젝트다.

--

## 어떤 언어로 언어를 만들 것인가

의외로 가장 중요한 질문 중 하나가 바로 언어를 개발할 언어를 무엇으로 선택하느냐이다. Rust 컴파일러는 Rust로 작성되어 있고, C 컴파일러인 GCC와 Clang은 C++로 작성되어 있으며, Haskell 컴파일러는 Haskell로 작성되어 있다. 겉으로 보면 자기 자신으로 만들어진 것처럼 보이지만, 사실 이건 결과일 뿐이다.

이 언어들의 공통점은 첫 번째 컴파일러 버전은 절대 자기 자신의 언어로 만들어지지 않았다는 점이다. C 컴파일러는 처음에 어셈블리어로 작성되었고, Rust는 OCaml과 C로 시작했으며, Haskell은 LML이라는 언어로 초기 컴파일러를 만든 뒤 빠르게 Haskell로 전환했다. 셀프 호스팅, 즉 부트스트래핑은 언어 개발의 목표일 수는 있어도 출발점은 아니다. 외부 언어는 필수다.

프로그래밍 언어 개발에 가장 많이 쓰이는 언어는 여전히 C와 C++이다. C는 전통적으로 컴파일러와 시스템 프로그래밍에 강하고, C++는 LLVM 같은 대규모 컴파일러 툴체인이 C++로 작성되어 있다는 점이 크다. 여기에 Rust도 점점 많이 쓰이고 있다. Rust는 표준 라이브러리가 잘 갖춰져 있고 외부 라이브러리 생태계도 풍부하다. 실제로 Wave는 Rust와 표준 라이브러리, 일부 색 처리와 정규 표현식 라이브러리만으로 구현되었고, 파서와 렉서는 전부 표준 라이브러리만으로 만들어졌다. 백엔드는 LLVM을 사용했다.

또 하나 흥미로운 점은 함수형 언어다. Rust의 초기 컴파일러가 OCaml로 작성되었고, Haskell 역시 함수형 언어 기반으로 시작했다. 함수형 언어는 AST 처리나 컴파일러 구조를 표현하는 데 매우 강력한 도구가 된다.

---

## 왜 스크립트 언어는 추천하지 않는가

Python이나 JavaScript로 프로그래밍 언어를 만들고 싶어하는 사람은 생각보다 많다. 접근성이 좋고, 이미 익숙하며, 문법도 간결하기 때문이다. 실제로 간단한 인터프리터나 토이 언어를 만드는 데에는 충분히 좋은 선택일 수 있고, 아이디어를 빠르게 검증하는 프로토타입 단계에서는 분명 장점이 있다.

하지만 언어 개발을 “끝까지 가져갈 생각”이라면 이야기가 달라진다. 컴파일러는 단순한 프로그램이 아니다. 수많은 AST 노드를 생성하고, 타입 정보를 유지하며, 스코프를 관리하고, 중간 표현을 만들고, 최적화 단계를 거친 뒤 최종 결과물을 만들어낸다. 이 과정에서 성능과 메모리 제어는 단순한 편의가 아니라 필수 조건이 된다.

스크립트 언어는 기본적으로 런타임 오버헤드가 크고, 메모리 구조를 세밀하게 제어하기 어렵다. 작은 언어에서는 문제가 없지만, 언어가 성장하면서 컴파일 시간이 길어지고 구조가 복잡해질수록 그 한계가 분명히 드러난다. 특히 대형 프로젝트를 컴파일하거나, 셀프 호스팅을 시도하는 단계에 이르면 성능 차이는 체감이 아니라 현실적인 장애가 된다.

또 하나 중요한 이유는 셀프 호스팅이다. 언어 개발의 자연스러운 목표 중 하나는 “이 언어로 이 언어의 컴파일러를 컴파일한다”는 단계에 도달하는 것이다. 이때 컴파일러 자체가 컴파일 언어로 작성되어 있으면 구조적으로 훨씬 유리하다. 빌드 시스템, 배포, 크로스 컴파일, 성능 튜닝까지 모든 면에서 장점이 크다.

그래서 장기적으로 언어를 유지하고 확장할 생각이라면, 처음부터 C, C++, Rust 같은 컴파일 언어를 선택하는 편이 훨씬 현실적인 선택이 된다.

---

## IR은 언어의 중추 신경계다

IR, 즉 중간 표현은 언어의 프론트엔드와 백엔드를 연결하는 핵심 구조다. 많은 사람들이 언어 개발을 “파서 + 코드 생성” 정도로 생각하지만, 실제로는 IR이 언어 전체의 구조를 결정한다고 해도 과언이 아니다.

소스 코드를 곧바로 기계어로 변환하면 구현은 단순해 보일 수 있다. 하지만 그렇게 되면 언어 문법, 최적화, 타겟 아키텍처가 전부 뒤엉키게 된다. 조금만 언어 기능이 늘어나도 코드가 걷잡을 수 없이 복잡해진다. IR은 이런 문제를 분리하기 위해 존재한다.

잘 설계된 IR은 언어 문법과 실행 플랫폼을 분리해준다. 프론트엔드는 “이 코드가 무엇을 의미하는가”에만 집중하고, 백엔드는 “이 의미를 어떻게 실행할 것인가”에만 집중할 수 있다. 이 덕분에 언어 문법을 바꿔도 백엔드를 거의 수정하지 않아도 되고, 반대로 새로운 플랫폼을 추가해도 프론트엔드는 그대로 둘 수 있다.

LLVM이 널리 쓰이는 이유도 여기에 있다. LLVM IR은 이미 수많은 최적화 패스와 아키텍처 지원을 갖추고 있어서, 언어 개발자는 “언어 그 자체”에 집중할 수 있다. 직접 IR을 설계하는 것도 좋은 경험이지만, 초기 단계에서는 기존 IR을 활용하는 것이 현실적인 선택이 되는 경우가 많다.

결국 IR은 단순한 중간 단계가 아니다. 언어의 확장성, 유지보수성, 그리고 생존 가능성을 결정하는 뼈대다.

---

## 에러 메시지는 언어의 성격을 드러낸다

에러 메시지는 언어가 사용자를 어떻게 대하는지를 그대로 보여준다. 같은 문법 오류라도 어떤 언어는 “unexpected token” 한 줄로 끝내고, 어떤 언어는 왜 이 코드가 잘못되었는지, 무엇을 의도했을 가능성이 있는지까지 알려준다. 이 차이는 단순한 친절함의 문제가 아니라, 언어에 대한 신뢰의 문제다.

사용자는 에러 메시지를 가장 자주 마주한다. 문서를 읽는 시간보다 에러 메시지를 보는 시간이 훨씬 길다. 그렇기 때문에 에러 메시지가 불친절한 언어는 학습 비용이 급격히 올라가고, 초보자에게는 진입 장벽이 된다.

초기 언어 개발 단계에서 모든 에러를 친절하게 만들 필요는 없다. 하지만 최소한 에러를 구조적으로 표현할 수 있는 기반은 처음부터 설계해야 한다. 위치 정보, 토큰 정보, 에러 종류를 명확히 나누어두지 않으면 나중에 에러 메시지를 개선하고 싶어도 구조 자체를 뜯어고쳐야 하는 상황이 온다.

좋은 에러 메시지는 문서보다 강력한 튜토리얼이 된다. 실제로 많은 사용자는 공식 문서를 읽기 전에 에러 메시지를 통해 언어를 배운다.

---

## 표준 라이브러리는 선택이 아니라 필수다

언어 문법이 아무리 잘 만들어졌어도, 표준 라이브러리가 없으면 그 언어는 현실에서 쓰이기 어렵다. 모든 프로그램이 콘솔 출력부터 직접 구현해야 하고, 문자열 처리나 파일 접근을 전부 처음부터 작성해야 한다면 그 언어는 실험용을 넘어서기 힘들다.

표준 라이브러리는 언어의 “기본 생활 도구”다. 입출력, 문자열, 파일, 네트워크, 시간 같은 기능은 거의 모든 프로그램에서 필요하다. 이조차 제공되지 않는 언어는 알고리즘 연습이나 계산 실험 정도에만 머무르게 된다.

처음부터 방대한 표준 라이브러리를 만들 필요는 없다. 오히려 최소한의 기능을 안정적으로 제공하는 것이 더 중요하다. 이후 언어가 성장하고 사용 사례가 늘어나면, 실제로 필요한 기능부터 천천히 추가하면 된다. 중요한 것은 “이 언어로 뭔가를 바로 만들 수 있다”는 감각을 사용자에게 주는 것이다.

---

## FFI는 언어를 현실로 끌어온다

일반적인 범용 프로그래밍 언어를 만든다면 FFI는 거의 필수라고 봐도 된다. 처음 만든 언어에는 프레임워크도 없고, 라이브러리도 없다. 모든 것을 자체 구현으로 해결하려고 하면 언어는 성장하기 전에 지쳐서 멈춰버린다.

FFI는 기존에 존재하는 수십 년치 인프라를 그대로 활용할 수 있게 해준다. 운영체제 API, 네이티브 라이브러리, 각종 툴체인을 바로 사용할 수 있다는 것은 언어에게 엄청난 힘이다. 언어 자체는 작아도, 할 수 있는 일은 갑자기 현실 세계 수준으로 확장된다.

언어가 성장하고 사용자와 기여자가 늘어나면, 언젠가는 FFI에 의존하지 않는 순수한 생태계가 만들어질 수도 있다. 하지만 그 단계에 도달하기 전까지 FFI는 언어를 살아 있게 만드는 생명선에 가깝다.

만약 FFI를 구현한 뒤 바인딩할 프로젝트를 고민한다면, 나는 두말하지 않고 raylib를 추천한다. raylib는 C로 작성된 가벼운 게임 라이브러리로, 수많은 언어에 바인딩되어 있다. 많은 언어들이 raylib 바인딩을 통해 FFI의 완성도를 검증했고, 그만큼 언어 테스트용으로도 매우 적합하다.

---

## 문서와 예제가 없으면 언어는 존재하지 않는다

마지막으로, 문서와 예제는 단순한 부가 요소가 아니다. 문서와 예제가 없는 언어는 사실상 존재하지 않는 언어와 다를 바 없다. README, 기본 문법 설명, 간단한 예제만 있어도 언어에 대한 첫인상은 완전히 달라진다.

특히 예제는 매우 중요하다. 언어 설명을 아무리 길게 써도, 실제 코드 한두 개를 보는 것보다 이해가 빠를 수는 없다. 예제가 없으면 사용자는 “그래서 이걸 어떻게 쓰라는 거지?”라는 질문에서 멈춰버린다.

그리고 가능하다면 문서는 반드시 영어로 작성하는 것이 좋다. 현재 개발자 커뮤니티에서 사실상의 공용어는 영어이고, 자료와 토론, 기여 역시 대부분 영어로 이루어진다. 영어 문서가 없는 언어는 처음부터 접근 가능한 사용자 층이 극단적으로 줄어든다.

---

## 마무리하며

프로그래밍 언어를 만든다는 것은 문법을 설계하는 일이 아니다. 문제를 정의하고, 그 문제에 대한 선택을 끝까지 책임지는 일이다. 완벽한 언어를 만들 필요는 없다. 대신, 왜 이 언어가 존재해야 하는지는 분명해야 한다. 그 질문에 답할 수 있다면, 이미 절반은 만든 것이다.